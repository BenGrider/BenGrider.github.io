QUESTION
1
Two Sum
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> answer = {};
        for(int i = 0 ; i < nums.size() ; i++) {
            for(int j = 1 ; j < nums.size() ; j++) {
                if(nums[i] + nums[j] == target && i != j) {
                    vector<int> answer = {i, j};
                    return answer;
                }
            }
        }
        return answer;
    }

};
/*

Using two for loops go through each combination of index i and j and compare
the summation of them. 

If true, which in constraints there is always 1 correct answer, return the
index i, and j in a vector of type int

If false, I returned an empty vector.

Line 7: if(nums[i] + nums[j] == target) {
Possible issues with code on line 7: If the target value is never reached, 
then i and j will be equal and be representing the same value. 
If this value is half the target value, then there will be a false positive given to the output.

Fix: Add an additional clause that states i cannot equal j.
Line 7 Updated: if(nums[i] + nums[j] == target && i != j)

*/
-1

QUESTION
2
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* returnHead = new ListNode(0);
        ListNode* curr = returnHead;
        int carry = 0;
        int currNodeVal;
        while(l1 != nullptr || l2 != nullptr || carry != 0){
            //ternary operator
            int l1Val = (l1 != nullptr) ? l1->val : 0; 
            int l2Val = (l2 != nullptr) ? l2->val : 0; 
            int currNodeVal = l1Val + l2Val + carry;

            carry = currNodeVal / 10;
            currNodeVal = currNodeVal % 10;
            curr->next = new ListNode(currNodeVal);
            curr = curr->next;

            if(l1 != nullptr) { l1 = l1->next; }
            if(l2 != nullptr) { l2 = l2->next; }

        }
        return returnHead->next;
    }
    
};
-1
